(function() {
  var WorkspaceView, path;

  WorkspaceView = require('atom').WorkspaceView;

  path = require('path');

  describe("bracket matching", function() {
    var buffer, editor, editorView, _ref;
    _ref = [], editorView = _ref[0], editor = _ref[1], buffer = _ref[2];
    beforeEach(function() {
      atom.config.set('bracket-matcher.autocompleteBrackets', true);
      atom.workspaceView = new WorkspaceView;
      atom.workspaceView.attachToDom();
      waitsForPromise(function() {
        return atom.workspace.open('sample.js');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage('bracket-matcher');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-javascript');
      });
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-xml');
      });
      return runs(function() {
        editorView = atom.workspaceView.getActiveView();
        editor = editorView.editor;
        return buffer = editor.buffer, editor;
      });
    });
    describe("matching bracket highlighting", function() {
      describe("when the cursor is before a starting pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToEndOfLine();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          expect(editorView.underlayer.find('.bracket-matcher:first').width()).toBeGreaterThan(0);
          expect(editorView.underlayer.find('.bracket-matcher:last').width()).toBeGreaterThan(0);
          expect(editorView.underlayer.find('.bracket-matcher:first').height()).toBeGreaterThan(0);
          return expect(editorView.underlayer.find('.bracket-matcher:last').height()).toBeGreaterThan(0);
        });
      });
      describe("when the cursor is after a starting pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToEndOfLine();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
          return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
        });
      });
      describe("when the cursor is before an ending pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToBottom();
          editor.moveCursorLeft();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
        });
      });
      describe("when the cursor is after an ending pair", function() {
        return it("highlights the starting pair and ending pair", function() {
          editor.moveCursorToBottom();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
        });
      });
      describe("when there are unpaired brackets", function() {
        return it("highlights the correct start/end pairs", function() {
          editor.setText('(()');
          editor.setCursorBufferPosition([0, 0]);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(0);
          editor.setCursorBufferPosition([0, 1]);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 2]));
          editor.setCursorBufferPosition([0, 2]);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 2]));
          editor.setText('())');
          editor.setCursorBufferPosition([0, 0]);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 0]));
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
          editor.setCursorBufferPosition([0, 1]);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 0]));
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
          editor.setCursorBufferPosition([0, 2]);
          return expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(0);
        });
      });
      describe("when the cursor is moved off a pair", function() {
        return it("removes the starting pair and ending pair highlights", function() {
          editor.moveCursorToEndOfLine();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          editor.moveCursorToBeginningOfLine();
          return expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(0);
        });
      });
      describe("when the pair moves", function() {
        return it("repositions the highlights", function() {
          editor.moveCursorToEndOfLine();
          editor.moveCursorLeft();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          editor.backspaceToBeginningOfLine();
          return expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
        });
      });
      describe("when the font size changes", function() {
        return it("repositions the highlights", function() {
          editor.moveCursorToBottom();
          editor.moveCursorLeft();
          atom.config.set('editor.fontSize', editorView.getFontSize() + 10);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
        });
      });
      describe("when the soft wrap setting changes on the editor", function() {
        return it("repositions the highlights", function() {
          editorView.setWidthInChars(200);
          editor.setSoftWrap(true);
          editor.moveCursorToBottom();
          editor.moveCursorLeft();
          editorView.setWidthInChars(23);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
          editor.setSoftWrap(false);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([12, 0]));
          return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 28]));
        });
      });
      describe("pair balancing", function() {
        return describe("when a second starting pair preceeds the first ending pair", function() {
          return it("advances to the second ending pair", function() {
            editor.setCursorBufferPosition([8, 42]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([8, 42]));
            return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([8, 54]));
          });
        });
      });
      describe("when the cursor is destroyed", function() {
        return it("updates the highlights to use the editor's last cursor", function() {
          editor.setCursorBufferPosition([0, 29]);
          editor.addCursorAtBufferPosition([9, 0]);
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
          editor.consolidateSelections();
          expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(0);
          editor.setCursorBufferPosition([0, 29]);
          return expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
        });
      });
      return describe("HTML/XML tag matching", function() {
        beforeEach(function() {
          waitsForPromise(function() {
            return atom.workspace.open('sample.xml');
          });
          return runs(function() {
            editorView = atom.workspaceView.getActiveView();
            editor = editorView.editor;
            return buffer = editor.buffer, editor;
          });
        });
        describe("when on an opening tag", function() {
          return it("highlight the opening and closing tag", function() {
            buffer.setText("<test>\n  <test>text</test>\n  <!-- </test> -->\n</test>");
            editor.setCursorBufferPosition([0, 0]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([3, 2]));
            editor.setCursorBufferPosition([0, 1]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([3, 2]));
          });
        });
        describe("when on a closing tag", function() {
          return it("highlight the opening and closing tag", function() {
            buffer.setText("<test>\n  <!-- <test> -->\n  <test>text</test>\n</test>");
            editor.setCursorBufferPosition([3, 0]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([3, 2]));
            expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            editor.setCursorBufferPosition([3, 2]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([3, 2]));
            return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
          });
        });
        describe("when the tag spans multiple lines", function() {
          return it("highlights the opening and closing tag", function() {
            buffer.setText("<test\n  a=\"test\">\n  text\n</test>");
            editor.setCursorBufferPosition([3, 2]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([3, 2]));
            expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            editor.setCursorBufferPosition([0, 1]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([3, 2]));
          });
        });
        describe("when the tag has attributes", function() {
          return it("highlights the opening and closing tags", function() {
            buffer.setText("<test a=\"test\">\n  text\n</test>");
            editor.setCursorBufferPosition([2, 2]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([2, 2]));
            expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            editor.setCursorBufferPosition([0, 7]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([2, 2]));
          });
        });
        return describe("when the opening and closing tags are on the same line", function() {
          return it("highlight the opening and closing tags", function() {
            buffer.setText("<test>text</test>");
            editor.setCursorBufferPosition([0, 2]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
            expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 12]));
            editor.setCursorBufferPosition([0, 12]);
            expect(editorView.underlayer.find('.bracket-matcher:visible').length).toBe(2);
            expect(editorView.underlayer.find('.bracket-matcher:first').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 12]));
            return expect(editorView.underlayer.find('.bracket-matcher:last').position()).toEqual(editorView.pixelPositionForBufferPosition([0, 1]));
          });
        });
      });
    });
    describe("when bracket-matcher:go-to-matching-bracket is triggered", function() {
      describe("when the cursor is before the starting pair", function() {
        return it("moves the cursor to after the ending pair", function() {
          editor.moveCursorToEndOfLine();
          editor.moveCursorLeft();
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([12, 1]);
        });
      });
      describe("when the cursor is after the starting pair", function() {
        return it("moves the cursor to before the ending pair", function() {
          editor.moveCursorToEndOfLine();
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([12, 0]);
        });
      });
      describe("when the cursor is before the ending pair", function() {
        return it("moves the cursor to after the starting pair", function() {
          editor.setCursorBufferPosition([12, 0]);
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 29]);
        });
      });
      describe("when the cursor is after the ending pair", function() {
        return it("moves the cursor to before the starting pair", function() {
          editor.setCursorBufferPosition([12, 1]);
          editorView.trigger("bracket-matcher:go-to-matching-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 28]);
        });
      });
      return describe("when the cursor is not adjacent to a pair", function() {
        describe("when within a `{}` pair", function() {
          return it("moves the cursor to before the enclosing brace", function() {
            editor.setCursorBufferPosition([11, 2]);
            editorView.trigger("bracket-matcher:go-to-matching-bracket");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 28]);
          });
        });
        return describe("when within a `()` pair", function() {
          return it("moves the cursor to before the enclosing brace", function() {
            editor.setCursorBufferPosition([2, 14]);
            editorView.trigger("bracket-matcher:go-to-matching-bracket");
            return expect(editor.getCursorBufferPosition()).toEqual([2, 7]);
          });
        });
      });
    });
    describe("when bracket-matcher:go-to-enclosing-bracket is triggered", function() {
      describe("when within a `{}` pair", function() {
        return it("moves the cursor to before the enclosing brace", function() {
          editor.setCursorBufferPosition([11, 2]);
          editorView.trigger("bracket-matcher:go-to-enclosing-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 28]);
        });
      });
      return describe("when within a `()` pair", function() {
        return it("moves the cursor to before the enclosing brace", function() {
          editor.setCursorBufferPosition([2, 14]);
          editorView.trigger("bracket-matcher:go-to-enclosing-bracket");
          return expect(editor.getCursorBufferPosition()).toEqual([2, 7]);
        });
      });
    });
    describe("when bracket-match:select-inside-brackets is triggered", function() {
      describe("when the cursor on the left side of a bracket", function() {
        return it("selects the text inside the brackets", function() {
          editor.setCursorBufferPosition([0, 28]);
          editorView.trigger("bracket-matcher:select-inside-brackets");
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 29], [12, 0]]);
        });
      });
      describe("when the cursor on the right side of a brack", function() {
        return it("selects the text inside the brackets", function() {
          editor.setCursorBufferPosition([1, 30]);
          editorView.trigger("bracket-matcher:select-inside-brackets");
          return expect(editor.getSelectedBufferRange()).toEqual([[1, 30], [9, 2]]);
        });
      });
      return describe("when the cursor is inside the brackets", function() {
        return it("selects the text for the closest outer brackets", function() {
          editor.setCursorBufferPosition([6, 6]);
          editorView.trigger("bracket-matcher:select-inside-brackets");
          return expect(editor.getSelectedBufferRange()).toEqual([[4, 29], [7, 4]]);
        });
      });
    });
    describe("matching bracket deletion", function() {
      beforeEach(function() {
        return editor.buffer.setText("");
      });
      describe("when selection is not a matching pair of brackets", function() {
        return it("does not change the text", function() {
          editor.insertText("\"woah(");
          editor.selectAll();
          editorView.trigger("bracket-matcher:remove-brackets-from-selection");
          return expect(editor.buffer.getText()).toBe("\"woah(");
        });
      });
      return describe("when selecting a matching pair of brackets", function() {
        describe("on the same line", function() {
          beforeEach(function() {
            editor.buffer.setText("it \"does something\", :meta => true");
            editor.setSelectedBufferRange([[0, 3], [0, 19]]);
            return editorView.trigger("bracket-matcher:remove-brackets-from-selection");
          });
          it("removes the brackets", function() {
            return expect(editor.buffer.getText()).toBe("it does something, :meta => true");
          });
          return it("selects the newly unbracketed text", function() {
            return expect(editor.getSelectedText()).toBe("does something");
          });
        });
        return describe("on separate lines", function() {
          beforeEach(function() {
            editor.buffer.setText("it (\"does something\" do\nend)");
            editor.setSelectedBufferRange([[0, 3], [1, 4]]);
            return editorView.trigger("bracket-matcher:remove-brackets-from-selection");
          });
          it("removes the brackets", function() {
            return expect(editor.buffer.getText()).toBe("it \"does something\" do\nend");
          });
          return it("selects the newly unbracketed text", function() {
            return expect(editor.getSelectedText()).toBe("\"does something\" do\nend");
          });
        });
      });
    });
    describe("matching bracket insertion", function() {
      beforeEach(function() {
        return editor.buffer.setText("");
      });
      describe("when more than one character is inserted", function() {
        return it("does not insert a matching bracket", function() {
          editor.insertText("woah(");
          return expect(editor.buffer.getText()).toBe("woah(");
        });
      });
      describe("when there is a word character after the cursor", function() {
        return it("does not insert a matching bracket", function() {
          editor.buffer.setText("ab");
          editor.setCursorBufferPosition([0, 1]);
          editor.insertText("(");
          return expect(editor.buffer.getText()).toBe("a(b");
        });
      });
      describe("when autocompleteBrackets configuration is disabled", function() {
        return it("does not insert a matching bracket", function() {
          atom.config.set('bracket-matcher.autocompleteBrackets', false);
          editor.buffer.setText("}");
          editor.setCursorBufferPosition([0, 0]);
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe("{}");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        });
      });
      describe("when there are multiple cursors", function() {
        return it("inserts ) at each cursor", function() {
          editor.buffer.setText("()\nab\n[]\n12");
          editor.setCursorBufferPosition([3, 1]);
          editor.addCursorAtBufferPosition([2, 1]);
          editor.addCursorAtBufferPosition([1, 1]);
          editor.addCursorAtBufferPosition([0, 1]);
          editor.insertText(')');
          return expect(editor.buffer.getText()).toBe("())\na)b\n[)]\n1)2");
        });
      });
      describe("when there is a non-word character after the cursor", function() {
        return it("inserts a closing bracket after an opening bracket is inserted", function() {
          editor.buffer.setText("}");
          editor.setCursorBufferPosition([0, 0]);
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe("{}}");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        });
      });
      describe("when the cursor is at the end of the line", function() {
        return it("inserts a closing bracket after an opening bracket is inserted", function() {
          editor.buffer.setText("");
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe("{}");
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText('(');
          expect(buffer.lineForRow(0)).toBe("()");
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText('[');
          expect(buffer.lineForRow(0)).toBe("[]");
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText('"');
          expect(buffer.lineForRow(0)).toBe('""');
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          editor.buffer.setText("");
          editor.insertText("'");
          expect(buffer.lineForRow(0)).toBe("''");
          return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
        });
      });
      describe("when the cursor is on a closing bracket and a closing bracket is inserted", function() {
        describe("when the closing bracket was there previously", function() {
          return it("inserts a closing bracket", function() {
            editor.insertText('()x');
            editor.setCursorBufferPosition([0, 1]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("())x");
            return expect(editor.getCursorBufferPosition().column).toBe(2);
          });
        });
        return describe("when the closing bracket was automatically inserted from inserting an opening bracket", function() {
          it("only moves cursor over the closing bracket one time", function() {
            editor.insertText('(');
            expect(buffer.lineForRow(0)).toBe("()");
            editor.setCursorBufferPosition([0, 1]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("()");
            expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
            editor.setCursorBufferPosition([0, 1]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("())");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
          });
          it("moves cursor over the closing bracket after other text is inserted", function() {
            editor.insertText('(');
            editor.insertText('ok cool');
            expect(buffer.lineForRow(0)).toBe("(ok cool)");
            editor.setCursorBufferPosition([0, 8]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(ok cool)");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 9]);
          });
          it("works with nested brackets", function() {
            editor.insertText('(');
            editor.insertText('1');
            editor.insertText('(');
            editor.insertText('2');
            expect(buffer.lineForRow(0)).toBe("(1(2))");
            editor.setCursorBufferPosition([0, 4]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(1(2))");
            expect(editor.getCursorBufferPosition()).toEqual([0, 5]);
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(1(2))");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
          });
          it("works with mixed brackets", function() {
            editor.insertText('(');
            editor.insertText('}');
            expect(buffer.lineForRow(0)).toBe("(})");
            editor.insertText(')');
            expect(buffer.lineForRow(0)).toBe("(})");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
          });
          return it("closes brackets with the same begin/end character correctly", function() {
            editor.insertText('"');
            editor.insertText('ok');
            expect(buffer.lineForRow(0)).toBe('"ok"');
            expect(editor.getCursorBufferPosition()).toEqual([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe('"ok"');
            return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
          });
        });
      });
      describe("when there is text selected on a single line", function() {
        it("wraps the selection with brackets", function() {
          editor.setText('text');
          editor.moveCursorToBottom();
          editor.selectToTop();
          editor.selectAll();
          editor.insertText('(');
          expect(buffer.getText()).toBe('(text)');
          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 5]]);
          return expect(editor.getSelection().isReversed()).toBeTruthy();
        });
        return describe("when the bracket-matcher.wrapSelectionsInBrackets is falsy", function() {
          return it("does not wrap the selection in brackets", function() {
            atom.config.set('bracket-matcher.wrapSelectionsInBrackets', false);
            editor.setText('text');
            editor.moveCursorToBottom();
            editor.selectToTop();
            editor.selectAll();
            editor.insertText('(');
            expect(buffer.getText()).toBe('(');
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 1]]);
          });
        });
      });
      describe("when there is text selected on multiple lines", function() {
        it("wraps the selection with brackets", function() {
          editor.insertText('text\nabcd');
          editor.moveCursorToBottom();
          editor.selectToTop();
          editor.selectAll();
          editor.insertText('(');
          expect('(text\nabcd)').toBe(buffer.getText());
          expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [1, 4]]);
          return expect(editor.getSelection().isReversed()).toBeTruthy();
        });
        return describe("when there are multiple selections", function() {
          return it("wraps each selection with brackets", function() {
            editor.setText("a b\nb c\nc b");
            editor.setSelectedBufferRanges([[[0, 2], [0, 3]], [[1, 0], [1, 1]], [[2, 2], [2, 3]]]);
            editor.insertText('"');
            expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 4]], [[1, 1], [1, 2]], [[2, 3], [2, 4]]]);
            expect(buffer.lineForRow(0)).toBe('a "b"');
            expect(buffer.lineForRow(1)).toBe('"b" c');
            return expect(buffer.lineForRow(2)).toBe('c "b"');
          });
        });
      });
      describe("when inserting a quote", function() {
        describe("when a word character is before the cursor", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("abc");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe("abc\"");
            editor.buffer.setText("abc");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('\'');
            return expect(buffer.lineForRow(0)).toBe("abc\'");
          });
        });
        describe("when a quote is before the cursor", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("''");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText("'");
            expect(buffer.lineForRow(0)).toBe("'''");
            editor.buffer.setText('""');
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe('"""');
            editor.buffer.setText('``');
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('`');
            expect(buffer.lineForRow(0)).toBe('```');
            editor.buffer.setText("''");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            return expect(buffer.lineForRow(0)).toBe("''\"\"");
          });
        });
        describe("when a non word character is before the cursor", function() {
          return it("automatically inserts the closing quote", function() {
            editor.buffer.setText("ab@");
            editor.setCursorBufferPosition([0, 3]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe("ab@\"\"");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
          });
        });
        describe("when the cursor is on an empty line", function() {
          return it("automatically inserts the closing quote", function() {
            editor.buffer.setText("");
            editor.setCursorBufferPosition([0, 0]);
            editor.insertText('"');
            expect(buffer.lineForRow(0)).toBe("\"\"");
            return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          });
        });
        describe("when the select option to Editor::insertText is true", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("");
            editor.setCursorBufferPosition([0, 0]);
            editor.insertText('"', {
              select: true
            });
            expect(buffer.lineForRow(0)).toBe('"');
            return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          });
        });
        return describe("when the undo option to Editor::insertText is 'skip'", function() {
          return it("does not automatically insert the closing quote", function() {
            editor.buffer.setText("");
            editor.setCursorBufferPosition([0, 0]);
            editor.insertText('"', {
              undo: 'skip'
            });
            expect(buffer.lineForRow(0)).toBe('"');
            return expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          });
        });
      });
      return describe("when return is pressed inside a matching pair", function() {
        it("puts cursor on autoindented empty line", function() {
          editor.insertText('void main() ');
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe('void main() {}');
          editor.insertNewline();
          expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
          expect(buffer.lineForRow(1)).toBe('  ');
          expect(buffer.lineForRow(2)).toBe('}');
          editor.setText('  void main() ');
          editor.insertText('{');
          expect(buffer.lineForRow(0)).toBe('  void main() {}');
          editor.insertNewline();
          expect(editor.getCursorBufferPosition()).toEqual([1, 4]);
          expect(buffer.lineForRow(1)).toBe('    ');
          return expect(buffer.lineForRow(2)).toBe('  }');
        });
        return describe("when undo is triggered", function() {
          return it("removes both newlines", function() {
            editor.insertText('void main() ');
            editor.insertText('{');
            editor.insertNewline();
            editor.undo();
            return expect(buffer.lineForRow(0)).toBe('void main() {}');
          });
        });
      });
    });
    return describe("matching bracket deletion", function() {
      return it("deletes the end bracket when it directly proceeds a begin bracket that is being backspaced", function() {
        buffer.setText("");
        editor.setCursorBufferPosition([0, 0]);
        editor.insertText('{');
        expect(buffer.lineForRow(0)).toBe("{}");
        editor.backspace();
        return expect(buffer.lineForRow(0)).toBe("");
      });
    });
  });

}).call(this);
