(function() {
  var $, EditorView, cheerio, extensionForFenceName, path, resolveImagePaths, roaster, sanitize, tokenizeCodeBlocks, _, _ref;

  path = require('path');

  _ = require('underscore-plus');

  cheerio = require('cheerio');

  _ref = require('atom'), $ = _ref.$, EditorView = _ref.EditorView;

  roaster = null;

  extensionForFenceName = require('./extension-helper').extensionForFenceName;

  exports.toHtml = function(text, filePath, callback) {
    var options;
    if (roaster == null) {
      roaster = require('roaster');
    }
    options = {
      sanitize: false,
      breaks: atom.config.get('markdown-preview.breakOnSingleNewline')
    };
    return roaster(text, options, (function(_this) {
      return function(error, html) {
        if (error) {
          return callback(error);
        } else {
          html = sanitize(html);
          html = resolveImagePaths(html, filePath);
          html = tokenizeCodeBlocks(html);
          return callback(null, html.html().trim());
        }
      };
    })(this));
  };

  exports.toText = function(text, filePath, callback) {
    return exports.toHtml(text, filePath, function(error, html) {
      var string;
      if (error) {
        return callback(error);
      } else {
        string = $(document.createElement('div')).append(html)[0].innerHTML;
        return callback(error, string);
      }
    });
  };

  sanitize = function(html) {
    var attribute, attributesToRemove, o, _i, _len;
    o = cheerio.load("<div>" + html + "</div>");
    o('script').remove();
    attributesToRemove = ['onabort', 'onblur', 'onchange', 'onclick', 'ondbclick', 'onerror', 'onfocus', 'onkeydown', 'onkeypress', 'onkeyup', 'onload', 'onmousedown', 'onmousemove', 'onmouseover', 'onmouseout', 'onmouseup', 'onreset', 'onresize', 'onscroll', 'onselect', 'onsubmit', 'onunload'];
    for (_i = 0, _len = attributesToRemove.length; _i < _len; _i++) {
      attribute = attributesToRemove[_i];
      o('*').removeAttr(attribute);
    }
    return o.html();
  };

  resolveImagePaths = function(html, filePath) {
    var img, imgElement, src, _i, _len, _ref1;
    html = $(html);
    _ref1 = html.find("img");
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      imgElement = _ref1[_i];
      img = $(imgElement);
      if (src = img.attr('src')) {
        if (src.match(/^(https?:\/\/)/)) {
          continue;
        }
        img.attr('src', path.resolve(path.dirname(filePath), src));
      }
    }
    return html;
  };

  tokenizeCodeBlocks = function(html) {
    var className, codeBlock, extension, fenceName, fontFamily, grammar, htmlEolInvisibles, lineText, preElement, text, tokens, _i, _j, _len, _len1, _ref1, _ref2;
    html = $(html);
    if (fontFamily = atom.config.get('editor.fontFamily')) {
      $(html).find('code').css('font-family', fontFamily);
    }
    _ref1 = $.merge(html.filter("pre"), html.find("pre"));
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      preElement = _ref1[_i];
      $(preElement).addClass("editor-colors");
      codeBlock = $(preElement.firstChild);
      if (!(className = codeBlock.attr('class'))) {
        continue;
      }
      fenceName = className.replace(/^lang-/, '');
      if (!(extension = extensionForFenceName(fenceName))) {
        continue;
      }
      text = codeBlock.text();
      grammar = atom.syntax.selectGrammar("foo." + extension, text);
      codeBlock.empty();
      _ref2 = grammar.tokenizeLines(text).slice(0, -1);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        tokens = _ref2[_j];
        lineText = _.pluck(tokens, 'value').join('');
        htmlEolInvisibles = '';
        codeBlock.append(EditorView.buildLineHtml({
          tokens: tokens,
          text: lineText,
          htmlEolInvisibles: htmlEolInvisibles
        }));
      }
    }
    return html;
  };

}).call(this);
