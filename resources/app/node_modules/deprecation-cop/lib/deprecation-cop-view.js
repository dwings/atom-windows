(function() {
  var $, $$, DeprecationCopView, Grim, ScrollView, fs, path, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('atom'), $ = _ref.$, $$ = _ref.$$, ScrollView = _ref.ScrollView;

  path = require('path');

  _ = require('underscore-plus');

  fs = require('fs-plus');

  Grim = require('grim');

  module.exports = DeprecationCopView = (function(_super) {
    __extends(DeprecationCopView, _super);

    function DeprecationCopView() {
      return DeprecationCopView.__super__.constructor.apply(this, arguments);
    }

    DeprecationCopView.content = function() {
      return this.div({
        "class": 'deprecation-cop pane-item native-key-bindings',
        tabindex: -1
      }, (function(_this) {
        return function() {
          return _this.div({
            "class": 'panel'
          }, function() {
            _this.div({
              "class": 'panel-heading'
            }, function() {
              _this.div({
                "class": 'btn-toolbar pull-right'
              }, function() {
                return _this.div({
                  "class": 'btn-group'
                }, function() {
                  return _this.button({
                    outlet: 'refreshButton',
                    "class": 'btn refresh'
                  }, 'Refresh');
                });
              });
              return _this.span("Deprecated calls");
            });
            return _this.ul({
              outlet: 'list',
              "class": 'list-tree has-collapsable-children'
            });
          });
        };
      })(this));
    };

    DeprecationCopView.prototype.initialize = function(_arg) {
      this.uri = _arg.uri;
      this.update();
      this.subscribe(Grim, 'updated', (function(_this) {
        return function() {
          return _this.refreshButton.show();
        };
      })(this));
      this.subscribe(this.refreshButton, 'click', (function(_this) {
        return function() {
          return _this.update();
        };
      })(this));
      this.subscribe(this, 'click', '.deprecation-info', function() {
        return $(this).parent().toggleClass('collapsed');
      });
      return this.subscribe(this, 'click', '.stack-line-location', function() {
        return atom.open({
          pathsToOpen: [this.href.replace('file://', '')]
        });
      });
    };

    DeprecationCopView.prototype.destroy = function() {
      return this.detach();
    };

    DeprecationCopView.prototype.getUri = function() {
      return this.uri;
    };

    DeprecationCopView.prototype.getTitle = function() {
      return 'Deprecation Cop';
    };

    DeprecationCopView.prototype.getPackagePathsByPackageName = function() {
      var name, _i, _len, _ref1;
      if (this.packagePathsByPackageName != null) {
        return this.packagePathsByPackageName;
      }
      this.packagePathsByPackageName = {};
      _ref1 = atom.packages.getLoadedPackages();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        name = _ref1[_i].name;
        this.packagePathsByPackageName[name] = atom.packages.resolvePackagePath(name);
      }
      return this.packagePathsByPackageName;
    };

    DeprecationCopView.prototype.getPackageName = function(stack) {
      var fileName, functionName, location, packageName, packagePath, relativePath, resourcePath, _ref1, _ref2;
      resourcePath = atom.getLoadSettings().resourcePath;
      _ref1 = stack[1], functionName = _ref1.functionName, location = _ref1.location, fileName = _ref1.fileName;
      _ref2 = this.getPackagePathsByPackageName();
      for (packageName in _ref2) {
        packagePath = _ref2[packageName];
        relativePath = path.relative(packagePath, fileName);
        if (!/^\.\./.test(relativePath)) {
          return packageName;
        }
      }
    };

    DeprecationCopView.prototype.createIssueUrl = function(packageName, deprecation, stack) {
      var body, repo, repoUrl, stacktrace, title, _ref1, _ref2, _ref3;
      if (!(repo = (_ref1 = atom.packages.getActivePackage(packageName)) != null ? (_ref2 = _ref1.metadata) != null ? _ref2.repository : void 0 : void 0)) {
        return;
      }
      repoUrl = (_ref3 = repo.url) != null ? _ref3 : repo;
      title = "" + (deprecation.getOriginName()) + " is deprecated.";
      stacktrace = stack.map(function(_arg) {
        var functionName, location;
        functionName = _arg.functionName, location = _arg.location;
        return "" + functionName + " (" + location + ")";
      }).join("\n");
      body = "" + (deprecation.getMessage()) + "\n```\n" + stacktrace + "\n```";
      return "" + repoUrl + "/issues/new?title=" + (encodeURI(title)) + "&body=" + (encodeURI(body));
    };

    DeprecationCopView.prototype.update = function() {
      var deprecation, deprecations, self, _i, _len, _results;
      this.refreshButton.hide();
      deprecations = Grim.getDeprecations();
      deprecations.sort(function(a, b) {
        return b.getCallCount() - a.getCallCount();
      });
      this.list.empty();
      if (deprecations.length === 0) {
        return this.list.append($$(function() {
          return this.li({
            "class": 'list-item'
          }, "No deprecated calls");
        }));
      } else {
        self = this;
        _results = [];
        for (_i = 0, _len = deprecations.length; _i < _len; _i++) {
          deprecation = deprecations[_i];
          _results.push(this.list.append($$(function() {
            return this.li({
              "class": 'deprecation list-nested-item collapsed'
            }, (function(_this) {
              return function() {
                _this.div({
                  "class": 'deprecation-info list-item'
                }, function() {
                  _this.span({
                    "class": 'text-highlight'
                  }, deprecation.getOriginName());
                  return _this.span(" (called " + (_.pluralize(deprecation.getCallCount(), 'time')) + ")");
                });
                return _this.ul({
                  "class": 'list'
                }, function() {
                  var stack, stacks, _j, _len1, _results1;
                  _this.li({
                    "class": 'list-item'
                  }, function() {
                    return _this.div({
                      "class": 'list-item text-success'
                    }, deprecation.getMessage());
                  });
                  stacks = deprecation.getStacks();
                  stacks.sort(function(a, b) {
                    return b.callCount - a.callCount;
                  });
                  _results1 = [];
                  for (_j = 0, _len1 = stacks.length; _j < _len1; _j++) {
                    stack = stacks[_j];
                    _results1.push(_this.li({
                      "class": 'list-item'
                    }, function() {
                      _this.div({
                        "class": 'btn-toolbar'
                      }, function() {
                        var packageName, url;
                        _this.span({
                          "class": 'icon icon-alert'
                        });
                        if (packageName = self.getPackageName(stack)) {
                          _this.span(packageName + (" package (called " + (_.pluralize(stack.callCount, 'time')) + ")"));
                          if (url = self.createIssueUrl(packageName, deprecation, stack)) {
                            return _this.a({
                              href: url
                            }, "Create Issue on " + packageName + " repo");
                          }
                        } else {
                          return _this.span("atom core" + (" (called " + (_.pluralize(stack.callCount, 'time')) + ")"));
                        }
                      });
                      return _this.div({
                        "class": 'stack-trace'
                      }, function() {
                        var fileName, functionName, location, _k, _len2, _ref1, _results2;
                        _results2 = [];
                        for (_k = 0, _len2 = stack.length; _k < _len2; _k++) {
                          _ref1 = stack[_k], functionName = _ref1.functionName, location = _ref1.location, fileName = _ref1.fileName;
                          _results2.push(_this.div({
                            "class": 'stack-line'
                          }, function() {
                            _this.span(functionName);
                            _this.span(" - ");
                            return _this.a({
                              "class": 'stack-line-location',
                              href: location
                            }, location);
                          }));
                        }
                        return _results2;
                      });
                    }));
                  }
                  return _results1;
                });
              };
            })(this));
          })));
        }
        return _results;
      }
    };

    return DeprecationCopView;

  })(ScrollView);

}).call(this);
